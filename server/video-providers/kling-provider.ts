import { BaseVideoProvider } from './base-provider';
import { VideoRequest, VideoResponse } from './types';

interface KlingConfig {
  apiKey: string;
  baseUrl: string;
  models: {
    [key: string]: {
      maxDuration: number;
      aspectRatios: string[];
      features: string[];
    };
  };
}

interface KlingVideoRequest {
  model: string;
  prompt: string;
  aspect_ratio?: string;
  duration?: number;
  mode?: string; // 'std' or 'pro'
  camera_control?: {
    type: string;
    config: any;
  };
}

interface KlingTaskResponse {
  code: number;
  message: string;
  data: {
    task_id: string;
    task_status: string;
    task_status_msg?: string;
  };
}

interface KlingTaskResult {
  code: number;
  message: string;
  data: {
    task_id: string;
    task_status: string;
    task_status_msg?: string;
    task_result?: {
      videos: Array<{
        id: string;
        url: string;
        duration: number;
        cover_image_url?: string;
      }>;
    };
    created_at: number;
    updated_at: number;
  };
}

export class KlingProvider extends BaseVideoProvider {
  private config: KlingConfig;
  private rateLimitDelay = 1000; // 1 second between requests

  constructor() {
    super('kling');
    
    if (!process.env.KLING_API_KEY) {
      throw new Error('KLING_API_KEY environment variable is required');
    }

    this.config = {
      apiKey: process.env.KLING_API_KEY,
      baseUrl: 'https://api.piapi.ai/api/kling',
      models: {
        'kling-v1': {
          maxDuration: 10, // Kling supports up to 10 seconds
          aspectRatios: ['16:9', '9:16', '1:1'],
          features: ['text-to-video', 'image-to-video']
        },
        'kling-v1-5': {
          maxDuration: 10,
          aspectRatios: ['16:9', '9:16', '1:1'],
          features: ['text-to-video', 'image-to-video', 'camera-control']
        }
      }
    };
  }

  async generateVideo(request: VideoRequest): Promise<VideoResponse> {
    console.log('Starting Kling video generation:', {
      contentLength: request.content.length,
      duration: request.duration,
      quality: request.quality
    });

    try {
      // Build prompt from story content
      const prompt = this.buildPrompt(request);
      
      // Create video generation task
      const taskResponse = await this.createVideoTask({
        model: request.quality === 'high' ? 'kling-v1-5' : 'kling-v1',
        prompt,
        aspect_ratio: this.getAspectRatio(request.aspectRatio),
        duration: Math.min(request.duration || 5, 10), // Max 10 seconds
        mode: request.quality === 'high' ? 'pro' : 'std'
      });

      if (taskResponse.code !== 0) {
        throw new Error(`Kling task creation failed: ${taskResponse.message}`);
      }

      const taskId = taskResponse.data.task_id;
      console.log(`Kling task created: ${taskId}`);

      // Wait for completion
      const result = await this.waitForCompletion(taskId);
      
      if (!result.data.task_result?.videos?.[0]) {
        throw new Error('No video generated by Kling');
      }

      const video = result.data.task_result.videos[0];
      
      return {
        videoUrl: video.url,
        thumbnailUrl: video.cover_image_url,
        duration: video.duration,
        provider: 'kling',
        metadata: {
          taskId,
          model: request.quality === 'high' ? 'kling-v1-5' : 'kling-v1',
          promptUsed: prompt
        }
      };

    } catch (error: any) {
      console.error('Kling generation failed:', error);
      throw new Error(`Kling provider failed: ${error.message}`);
    }
  }

  private async createVideoTask(request: KlingVideoRequest): Promise<KlingTaskResponse> {
    const response = await fetch(`${this.config.baseUrl}/v1/videos/text2video`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.config.apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(request)
    });

    if (!response.ok) {
      throw new Error(`Kling API error: ${response.status} ${response.statusText}`);
    }

    return await response.json();
  }

  private async waitForCompletion(taskId: string): Promise<KlingTaskResult> {
    const maxAttempts = 60; // 5 minutes with 5-second intervals
    let attempts = 0;

    console.log(`Polling Kling task ${taskId} for completion`);

    while (attempts < maxAttempts) {
      try {
        const response = await fetch(`${this.config.baseUrl}/v1/videos/${taskId}`, {
          headers: {
            'Authorization': `Bearer ${this.config.apiKey}`
          }
        });

        if (!response.ok) {
          throw new Error(`Kling status check failed: ${response.status}`);
        }

        const result: KlingTaskResult = await response.json();
        
        if (result.data.task_status === 'succeed') {
          console.log(`Kling task ${taskId} completed successfully`);
          return result;
        } else if (result.data.task_status === 'failed') {
          throw new Error(`Kling task failed: ${result.data.task_status_msg || 'Unknown error'}`);
        }
        
        console.log(`Kling task ${taskId} status: ${result.data.task_status}, waiting...`);
        
        // Wait 5 seconds before next poll
        await new Promise(resolve => setTimeout(resolve, 5000));
        attempts++;
        
      } catch (error) {
        console.error('Error polling Kling task status:', error);
        attempts++;
        
        if (attempts >= maxAttempts) {
          throw new Error(`Kling polling failed after ${maxAttempts} attempts: ${error}`);
        }
        
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    }

    throw new Error(`Kling task ${taskId} did not complete within timeout`);
  }

  private buildPrompt(request: VideoRequest): string {
    let prompt = '';

    // Add character information
    if (request.characters && request.characters.length > 0) {
      const characterDesc = request.characters.map(char => 
        `${char.name}: ${char.description || 'character'}`
      ).join(', ');
      prompt += `Characters: ${characterDesc}. `;
    }

    // Add scene information
    if (request.scenes && request.scenes.length > 0) {
      const sceneDesc = request.scenes.slice(0, 2).map(scene => 
        scene.backgroundDescription || scene.title || 'scene'
      ).join(', ');
      prompt += `Scenes: ${sceneDesc}. `;
    }

    // Add story content (filtered for safety)
    const storyExcerpt = this.filterContent(request.content.substring(0, 300));
    prompt += `Story: ${storyExcerpt}. `;

    // Add visual style
    prompt += 'Professional cinematic video with high quality visuals, smooth camera movements, and engaging storytelling.';

    console.log('Kling prompt generated:', {
      length: prompt.length,
      preview: prompt.substring(0, 100) + '...'
    });

    return prompt;
  }

  private filterContent(content: string): string {
    // Basic content filtering for video generation
    return content
      .replace(/\b(violence|violent|kill|murder|death|blood|weapon)\b/gi, 'conflict')
      .replace(/\b(steal|stolen|theft|crime|criminal)\b/gi, 'adventure')
      .replace(/\b(explicit|inappropriate|adult)\b/gi, 'dramatic');
  }

  private getAspectRatio(requested?: string): string {
    const supportedRatios = ['16:9', '9:16', '1:1'];
    return supportedRatios.includes(requested || '') ? requested! : '16:9';
  }

  async isHealthy(): Promise<boolean> {
    try {
      // Test API connectivity with a simple status check
      const response = await fetch(`${this.config.baseUrl}/v1/videos/quota`, {
        headers: {
          'Authorization': `Bearer ${this.config.apiKey}`
        }
      });
      return response.ok;
    } catch {
      return false;
    }
  }

  getSupportedFeatures(): string[] {
    return ['text-to-video', 'custom-duration', 'multiple-aspect-ratios'];
  }

  getMaxDuration(): number {
    return 10; // Kling max duration
  }
}