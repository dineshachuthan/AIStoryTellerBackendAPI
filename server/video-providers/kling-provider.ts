import { BaseVideoProvider } from './base-provider';
import { VideoRequest, VideoResponse } from './types';

interface KlingConfig {
  apiKey: string;
  secretKey: string;
  baseUrl: string;
  models: {
    [key: string]: {
      maxDuration: number;
      aspectRatios: string[];
      features: string[];
    };
  };
}

interface KlingVideoRequest {
  model: string;
  prompt: string;
  aspect_ratio?: string;
  duration?: number;
  mode?: string; // 'std' or 'pro'
  camera_control?: {
    type: string;
    config: any;
  };
}

interface KlingTaskResponse {
  code: number;
  message: string;
  data: {
    task_id: string;
    task_status: string;
    task_status_msg?: string;
  };
}

interface KlingTaskResult {
  code: number;
  message: string;
  data: {
    task_id: string;
    task_status: string;
    task_status_msg?: string;
    task_result?: {
      videos: Array<{
        id: string;
        url: string;
        duration: number;
        cover_image_url?: string;
      }>;
    };
    created_at: number;
    updated_at: number;
  };
}

export class KlingProvider extends BaseVideoProvider {
  private config: KlingConfig;
  private rateLimitDelay = 1000; // 1 second between requests

  constructor() {
    super('kling');
    
    if (!process.env.KLING_ACCESS_KEY || !process.env.KLING_SECRET_KEY) {
      throw new Error('KLING_ACCESS_KEY and KLING_SECRET_KEY environment variables are required');
    }

    this.config = {
      apiKey: `${process.env.KLING_ACCESS_KEY}:${process.env.KLING_SECRET_KEY}`,
      baseUrl: 'https://api.klingai.com',
      models: {
        'kling-v1': {
          maxDuration: 20, // Updated to 20 seconds as requested
          aspectRatios: ['16:9', '9:16', '1:1'],
          features: ['text-to-video', 'image-to-video']
        },
        'kling-v1-5': {
          maxDuration: 20, // Updated to 20 seconds as requested
          aspectRatios: ['16:9', '9:16', '1:1'],
          features: ['text-to-video', 'image-to-video', 'camera-control']
        }
      }
    };
  }

  async generateVideo(request: VideoRequest): Promise<VideoResponse> {
    console.log('Starting Kling video generation with enhanced character and scene support:', {
      contentLength: request.content.length,
      charactersCount: request.characters?.length || 0,
      scenesCount: request.scenes?.length || 0,
      duration: request.duration,
      quality: request.quality
    });

    try {
      // Build enhanced prompt with character and scene details
      const prompt = this.buildPrompt(request);
      
      // Log the full prompt for debugging
      console.log('Full Kling prompt being sent:', prompt);
      
      // Create video generation task with optimized settings
      const taskResponse = await this.createVideoTask({
        model: 'kling-v1', // Use basic model for cost-effective testing
        prompt,
        aspect_ratio: this.getAspectRatio(request.aspectRatio),
        duration: Math.min(request.duration || 10, 20), // Max 20 seconds as configured
        mode: 'std' // Standard mode for low cost, reliable results
      });

      if (taskResponse.code !== 0) {
        throw new Error(`Kling task creation failed: ${taskResponse.message}`);
      }

      const taskId = taskResponse.data.task_id;
      console.log(`Kling task created: ${taskId}`);

      // Wait for completion
      const result = await this.waitForCompletion(taskId);
      
      if (!result.data.task_result?.videos?.[0]) {
        throw new Error('No video generated by Kling');
      }

      const video = result.data.task_result.videos[0];
      
      return {
        videoUrl: video.url,
        thumbnailUrl: video.cover_image_url,
        duration: video.duration,
        provider: 'kling',
        metadata: {
          taskId,
          model: 'kling-v1',
          mode: 'std',
          resolution: 'low',
          promptUsed: prompt
        }
      };

    } catch (error: any) {
      console.error('Kling generation failed:', error);
      throw new Error(`Kling provider failed: ${error.message}`);
    }
  }

  private async createVideoTask(request: KlingVideoRequest): Promise<KlingTaskResponse> {
    console.log('Creating Kling video task with request:', {
      model: request.model,
      prompt: request.prompt.substring(0, 100) + '...',
      duration: request.duration,
      aspect_ratio: request.aspect_ratio,
      mode: request.mode
    });

    // Use the correct Kling API endpoint structure
    const endpoint = '/v1/videos/text2video';
    
    console.log(`Calling Kling API: ${this.config.baseUrl}${endpoint}`);
    
    // Use proper Kling API authentication format
    const timestamp = Date.now();
    const nonce = Math.random().toString(36).substring(2);
    const requestBody = JSON.stringify(request);
    
    // Create signature for Kling API (following Chinese API patterns)
    const stringToSign = `POST\n${endpoint}\n${timestamp}\n${nonce}\n${requestBody}`;
    const signature = require('crypto').createHmac('sha256', this.config.secretKey).update(stringToSign).digest('hex');
    
    console.log('Using Kling signature-based authentication');
    
    const response = await fetch(`${this.config.baseUrl}${endpoint}`, {
      method: 'POST',
      headers: {
        'Authorization': `${this.config.apiKey}:${signature}`,
        'X-Timestamp': timestamp.toString(),
        'X-Nonce': nonce,
        'Content-Type': 'application/json',
        'User-Agent': 'Storytelling-App/1.0'
      },
      body: requestBody
    });

    const responseText = await response.text();

    console.log('Kling API response status:', response.status);
    console.log('Kling API response:', responseText.substring(0, 500));

    // Parse response for detailed error analysis
    let jsonResponse;
    try {
      jsonResponse = JSON.parse(responseText);
    } catch (e) {
      throw new Error(`Kling API returned invalid JSON: ${responseText}`);
    }

    // Handle authentication errors specifically
    if (jsonResponse.code >= 1000 && jsonResponse.code <= 1099) {
      throw new Error(`Kling API authentication failed (Code ${jsonResponse.code}): ${jsonResponse.message}. Please verify your KLING_ACCESS_KEY and KLING_SECRET_KEY are correctly configured and activated in your Kling account.`);
    }

    // Handle other API errors
    if (!response.ok || jsonResponse.code !== 0) {
      throw new Error(`Kling API error (Code ${jsonResponse.code}): ${jsonResponse.message}`);
    }

    return jsonResponse;
  }

  private async waitForCompletion(taskId: string): Promise<KlingTaskResult> {
    const maxAttempts = 60; // 5 minutes with 5-second intervals
    let attempts = 0;

    console.log(`Polling Kling task ${taskId} for completion`);

    while (attempts < maxAttempts) {
      try {
        const response = await fetch(`${this.config.baseUrl}/v1/videos/${taskId}`, {
          headers: {
            'Authorization': this.config.apiKey // Use the working auth method
          }
        });

        if (!response.ok) {
          throw new Error(`Kling status check failed: ${response.status}`);
        }

        const result: KlingTaskResult = await response.json();
        
        if (result.data.task_status === 'succeed') {
          console.log(`Kling task ${taskId} completed successfully`);
          return result;
        } else if (result.data.task_status === 'failed') {
          throw new Error(`Kling task failed: ${result.data.task_status_msg || 'Unknown error'}`);
        }
        
        console.log(`Kling task ${taskId} status: ${result.data.task_status}, waiting...`);
        
        // Wait 5 seconds before next poll
        await new Promise(resolve => setTimeout(resolve, 5000));
        attempts++;
        
      } catch (error) {
        console.error('Error polling Kling task status:', error);
        attempts++;
        
        if (attempts >= maxAttempts) {
          throw new Error(`Kling polling failed after ${maxAttempts} attempts: ${error}`);
        }
        
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    }

    throw new Error(`Kling task ${taskId} did not complete within timeout`);
  }

  private buildPrompt(request: VideoRequest): string {
    let prompt = '';

    // Build detailed character descriptions with appearance and personality
    if (request.characters && request.characters.length > 0) {
      const characterDetails = request.characters.map(char => {
        let charDesc = `${char.name}`;
        
        // Add physical description if available
        if (char.description) {
          charDesc += ` (${this.filterContent(char.description)})`;
        }
        
        // Add personality traits
        if (char.personality) {
          charDesc += ` with ${this.filterContent(char.personality)} personality`;
        }
        
        // Add role context
        if (char.role) {
          charDesc += ` as ${char.role}`;
        }

        return charDesc;
      }).join(', ');
      
      prompt += `CHARACTERS: ${characterDetails}. `;
    }

    // Build detailed scene backgrounds with rich visual descriptions
    if (request.scenes && request.scenes.length > 0) {
      const sceneDetails = request.scenes.slice(0, 2).map((scene, index) => {
        let sceneDesc = `Scene ${index + 1}`;
        
        // Add location and setting
        if (scene.backgroundDescription) {
          sceneDesc += `: ${this.filterContent(scene.backgroundDescription)}`;
        } else if (scene.title) {
          sceneDesc += `: ${this.filterContent(scene.title)}`;
        }
        
        // Add atmospheric details from background object
        if (scene.background) {
          const bg = scene.background;
          if (bg.location) sceneDesc += ` in ${bg.location}`;
          if (bg.timeOfDay) sceneDesc += ` during ${bg.timeOfDay}`;
          if (bg.atmosphere) sceneDesc += ` with ${bg.atmosphere} atmosphere`;
          if (bg.lighting) sceneDesc += `, ${bg.lighting} lighting`;
          if (bg.visualDescription) sceneDesc += `, ${this.filterContent(bg.visualDescription)}`;
        }

        return sceneDesc;
      }).join('. ');
      
      prompt += `SCENES: ${sceneDetails}. `;
    }

    // Add filtered story narrative for context
    const storyExcerpt = this.filterContent(request.content.substring(0, 200));
    prompt += `STORY CONTEXT: ${storyExcerpt}. `;

    // Add cinematic style instructions optimized for Kling
    prompt += `VISUAL STYLE: Professional cinematic video with dynamic camera movements, rich detailed environments, expressive character animations, natural lighting transitions, and immersive storytelling. High-quality production with smooth motion and engaging visual narrative.`;

    console.log('Enhanced Kling prompt generated:', {
      length: prompt.length,
      charactersCount: request.characters?.length || 0,
      scenesCount: request.scenes?.length || 0,
      preview: prompt.substring(0, 150) + '...'
    });

    return prompt;
  }

  private filterContent(content: string): string {
    // Enhanced content filtering for Kling AI compliance
    return content
      // Violence and conflict
      .replace(/\b(violence|violent|kill|murder|death|blood|weapon|fight|attack)\b/gi, 'conflict')
      .replace(/\b(steal|stolen|theft|crime|criminal|rob)\b/gi, 'adventure')
      // Inappropriate content
      .replace(/\b(explicit|inappropriate|adult|mature)\b/gi, 'dramatic')
      // Fear and negative emotions
      .replace(/\b(terrified|terror|fear|scary|frightening)\b/gi, 'surprised')
      .replace(/\b(disgusting|revolting|horrible)\b/gi, 'unpleasant')
      // AI/technology themes that might be sensitive
      .replace(/\b(AI|artificial intelligence|robot|android|cyborg)\b/gi, 'technology')
      .replace(/\b(control|controlling|manipulation|manipulate)\b/gi, 'influence')
      // Dark themes
      .replace(/\b(dark|darkness|shadow|evil|sinister|menacing)\b/gi, 'mysterious')
      // Medical/disability content
      .replace(/\b(disease|illness|disabled|paralyzed|paralysed)\b/gi, 'challenge')
      // Enhance positive descriptors
      .replace(/\b(beautiful|gorgeous|stunning)\b/gi, 'visually striking')
      .replace(/\b(magical|mystical|enchanting)\b/gi, 'wondrous');
  }

  private getAspectRatio(requested?: string): string {
    const supportedRatios = ['16:9', '9:16', '1:1'];
    return supportedRatios.includes(requested || '') ? requested! : '16:9';
  }

  async isHealthy(): Promise<boolean> {
    try {
      // Test API connectivity with a simple status check
      const response = await fetch(`${this.config.baseUrl}/v1/videos/quota`, {
        headers: {
          'Authorization': `Bearer ${this.config.apiKey}`
        }
      });
      return response.ok;
    } catch {
      return false;
    }
  }

  getSupportedFeatures(): string[] {
    return ['text-to-video', 'custom-duration', 'multiple-aspect-ratios'];
  }

  getMaxDuration(): number {
    return 20; // Updated max duration for testing
  }
}